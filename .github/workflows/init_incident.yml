name: Incident

on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  initialize:
    if: contains(github.event.issue.labels.*.name, 'incident')
    runs-on: ubuntu-latest
    concurrency: 
      group: incident-init
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Parse Issue
        id: parse
        uses: actions/github-script@v6
        with:
          script: |
            const body = context.payload.issue.body || "";
            const extract = (regex) => {
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            };

            const protocol = extract(/### Protocol\s*\n+(.*)/);
            const txhash = extract(/### Tx Hash\s*\n+(.*)/);
            const auditorsRaw = extract(/### Auditors\s*\n+(.*)/);
            
            const chainRaw = extract(/### Chain\s*\n+(.*)/);
            const chainId = chainRaw ? chainRaw.match(/\((\d+)\)/)[1] : "1";

            if (!protocol || !txhash) {
              core.setFailed("Missing required fields: protocol or txhash.");
              return;
            }

            const auditors = auditorsRaw ? auditorsRaw.split(',').map(s => s.trim()).filter(s => s) : [];
            if (auditors.length === 0) {
              core.setFailed("At least one auditor is required.");
              return;
            }

            const newTitle = `[Incident]: ${protocol}`;
            if (context.payload.issue.title !== newTitle) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                title: newTitle
              });
            }

            // Auto-assign auditors
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              assignees: auditors
            });

            core.setOutput("protocol", protocol);
            core.setOutput("txhash", txhash);
            core.setOutput("chain_id", chainId);
            core.setOutput("auditors", JSON.stringify(auditors));

      - name: Fetch Metadata
        id: infura
        env:
          INFURA_KEY: ${{ secrets.INFURA_API_KEY }}
        run: |
          CHAIN_ID="${{ steps.parse.outputs.chain_id }}"
          TXHASH="${{ steps.parse.outputs.txhash }}"

          if [ -z "$INFURA_KEY" ]; then
            echo "::error::INFURA_API_KEY is not set."
            exit 1
          fi

          case $CHAIN_ID in
            1)           PREFIX="mainnet" ;;
            59144)       PREFIX="linea-mainnet" ;;
            137)         PREFIX="polygon-mainnet" ;;
            8453)        PREFIX="base-mainnet" ;;
            81457)       PREFIX="blast-mainnet" ;;
            10)          PREFIX="optimism-mainnet" ;;
            42161)       PREFIX="arbitrum-mainnet" ;;
            43114)       PREFIX="avalanche-mainnet" ;;
            56)          PREFIX="bsc-mainnet" ;;
            42220)       PREFIX="celo-mainnet" ;;
            324)         PREFIX="zksync-mainnet" ;;
            5000)        PREFIX="mantle-mainnet" ;;
            204)         PREFIX="opbnb-mainnet" ;;
            534352)      PREFIX="scroll-mainnet" ;;
            1329)        PREFIX="sei-mainnet" ;;
            11297108109) PREFIX="palm-mainnet" ;;
            *) echo "::error::Unsupported Chain ID: $CHAIN_ID"; exit 1 ;;
          esac

          RPC_URL="https://${PREFIX}.infura.io/v3/$INFURA_KEY"

          # 1. Get Block Number
          TX_RES=$(curl -s -X POST -H "Content-Type: application/json" --data "{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByHash\",\"params\":[\"$TXHASH\"],\"id\":1}" $RPC_URL)
          BLOCK_HEX=$(echo $TX_RES | jq -r '.result.blockNumber // empty' | tr -d '\r\n ')

          if [ -z "$BLOCK_HEX" ] || [ "$BLOCK_HEX" == "null" ]; then
            echo "::error::Failed to fetch block number."
            exit 1
          fi

          # 2. Get Timestamp
          BLOCK_RES=$(curl -s -X POST -H "Content-Type: application/json" --data "{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"$BLOCK_HEX\", false],\"id\":1}" $RPC_URL)
          TIMESTAMP_HEX=$(echo $BLOCK_RES | jq -r '.result.timestamp // empty' | tr -d '\r\n ')

          if [ -z "$TIMESTAMP_HEX" ] || [ "$TIMESTAMP_HEX" == "null" ]; then
             echo "::error::Failed to fetch timestamp."
             exit 1
          fi

          # 3. Convert
          BLOCK_NUM=$(printf "%d" $BLOCK_HEX)
          TIMESTAMP=$(printf "%d" $TIMESTAMP_HEX)
          DATE_STR=$(date -u -d @$TIMESTAMP +%Y-%m-%d)
          FORK_BLOCK=$((BLOCK_NUM - 1))

          # 4. Extract tx data
          ATTACKER=$(echo $TX_RES | jq -r '.result.from // "0x0000000000000000000000000000000000000000"')
          TARGET=$(echo $TX_RES | jq -r '.result.to // "0x0000000000000000000000000000000000000000"')
          INPUT_DATA=$(echo $TX_RES | jq -r '.result.input // "0x"')

          echo "block_number=$BLOCK_NUM" >> $GITHUB_OUTPUT
          echo "fork_block=$FORK_BLOCK" >> $GITHUB_OUTPUT
          echo "date=$DATE_STR" >> $GITHUB_OUTPUT
          echo "attacker=$ATTACKER" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "input_data=$INPUT_DATA" >> $GITHUB_OUTPUT
          
          # RPC alias for foundry.toml
          case $CHAIN_ID in
            1) echo "rpc_alias=mainnet" >> $GITHUB_OUTPUT ;;
            56) echo "rpc_alias=bsc" >> $GITHUB_OUTPUT ;;
            137) echo "rpc_alias=polygon" >> $GITHUB_OUTPUT ;;
            42161) echo "rpc_alias=arbitrum" >> $GITHUB_OUTPUT ;;
            10) echo "rpc_alias=optimism" >> $GITHUB_OUTPUT ;;
            43114) echo "rpc_alias=avalanche" >> $GITHUB_OUTPUT ;;
            8453) echo "rpc_alias=base" >> $GITHUB_OUTPUT ;;
            *) echo "rpc_alias=mainnet" >> $GITHUB_OUTPUT ;;
          esac
          
          BRANCH_NAME="incident/${DATE_STR}_${{ steps.parse.outputs.protocol }}"
          BRANCH_NAME=${BRANCH_NAME// /-}
          echo "TARGET_BRANCH=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Generate Templates
        run: |
          git config --global user.name "AuditBot"
          git config --global user.email "bot@audit.org"
          git checkout -b ${{ env.TARGET_BRANCH }}
          
          PROTOCOL="${{ steps.parse.outputs.protocol }}"
          DATE="${{ steps.infura.outputs.date }}"
          BLOCK="${{ steps.infura.outputs.block_number }}"
          FORK_BLOCK="${{ steps.infura.outputs.fork_block }}"
          CHAIN_ID="${{ steps.parse.outputs.chain_id }}"
          TXHASH="${{ steps.parse.outputs.txhash }}"
          ATTACKER="${{ steps.infura.outputs.attacker }}"
          TARGET="${{ steps.infura.outputs.target }}"
          INPUT_DATA="${{ steps.infura.outputs.input_data }}"
          RPC_ALIAS="${{ steps.infura.outputs.rpc_alias }}"
          
          DIR="test/${DATE}_${PROTOCOL}"
          mkdir -p "$DIR"
          mkdir -p "data/results"
          
          # 1. Base Contract
          cat > "$DIR/${PROTOCOL}Base.sol" << SOLEOF
          // SPDX-License-Identifier: UNLICENSED
          pragma solidity ^0.8.10;
          
          import "src/shared/BaseTest.sol";
          import "src/shared/FeatureTypes.sol";
          import "src/shared/interfaces.sol";
          
          /*
          @Protocol: ${PROTOCOL}
          @Date: ${DATE}
          @Attacker: ${ATTACKER}
          @Target: ${TARGET}
          @TxHash: ${TXHASH}
          @ChainId: ${CHAIN_ID}
          */
          
          abstract contract ${PROTOCOL}Base is BaseTest {
              function setUp() public virtual {
                  vm.createSelectFork("${RPC_ALIAS}", ${FORK_BLOCK});
                  target = ${TARGET};
              }
          }
          SOLEOF
          
          # 2. Replay Test
          INPUT_HEX="${INPUT_DATA#0x}"
          cat > "$DIR/Replay.t.sol" << SOLEOF
          // SPDX-License-Identifier: UNLICENSED
          pragma solidity ^0.8.10;
          
          import "./${PROTOCOL}Base.sol";
          
          contract ReplayTest is ${PROTOCOL}Base {
              function testReplay() public recordMetrics("REPLAY") {
                  beneficiary = ${ATTACKER};
                  vm.startPrank(${ATTACKER});
                  (bool success, ) = ${TARGET}.call(hex"${INPUT_HEX}");
                  require(success, "Replay failed");
                  vm.stopPrank();
              }
          }
          SOLEOF
          
          # 3. README
          cat > "$DIR/README.md" << MDEOF
          # ${PROTOCOL} Incident
          
          | Field | Value |
          |-------|-------|
          | Date | ${DATE} |
          | Chain | ${CHAIN_ID} |
          | Block | ${BLOCK} |
          | Tx | \`${TXHASH}\` |
          | Attacker | \`${ATTACKER}\` |
          | Target | \`${TARGET}\` |
          
          ## Auditors
          $(echo '${{ steps.parse.outputs.auditors }}' | jq -r '.[] | "- [ ] @\(.)"')
          
          ## Status
          - [x] Workspace initialized
          - [ ] Replay verified
          - [ ] Analysis complete
          MDEOF
          
          # 4. PoC for each auditor
          for auditor in $(echo '${{ steps.parse.outputs.auditors }}' | jq -r '.[]'); do
            cat > "$DIR/PoC_${auditor}.t.sol" << SOLEOF
          // SPDX-License-Identifier: UNLICENSED
          pragma solidity ^0.8.10;
          
          import "./${PROTOCOL}Base.sol";
          
          contract PoC_${auditor} is ${PROTOCOL}Base {
              // Fill in your analysis
              Analysis analysis = Analysis({
                  vulnType: VulnerabilityType.UNKNOWN,
                  attackVector: AttackVector.UNKNOWN,
                  severityScore: 0,
                  rootCause: ""
              });
          
              function testExploit() public recordAnalysis("PoC_${auditor}", analysis) {
                  // Implement your exploit logic
              }
          }
          SOLEOF
          done
          
      - name: Verify Replay
        id: verify
        env:
          MAINNET_RPC_URL: ${{ secrets.MAINNET_RPC_URL || 'https://eth.llamarpc.com' }}
          BSC_RPC_URL: ${{ secrets.BSC_RPC_URL || 'https://bsc-dataseed.binance.org' }}
          ARBITRUM_RPC_URL: ${{ secrets.ARBITRUM_RPC_URL || 'https://arb1.arbitrum.io/rpc' }}
          OPTIMISM_RPC_URL: ${{ secrets.OPTIMISM_RPC_URL || 'https://mainnet.optimism.io' }}
          POLYGON_RPC_URL: ${{ secrets.POLYGON_RPC_URL || 'https://polygon-rpc.com' }}
          AVALANCHE_RPC_URL: ${{ secrets.AVALANCHE_RPC_URL || 'https://api.avax.network/ext/bc/C/rpc' }}
          FANTOM_RPC_URL: ${{ secrets.FANTOM_RPC_URL || 'https://rpc.ftm.tools' }}
          BASE_RPC_URL: ${{ secrets.BASE_RPC_URL || 'https://mainnet.base.org' }}
        run: |
          if forge test --match-test testReplay -vvv 2>&1 | tee replay_result.txt | grep -q "PASS"; then
            echo "REPLAY_STATUS=PASS" >> $GITHUB_ENV
          else
            echo "REPLAY_STATUS=FAIL" >> $GITHUB_ENV
          fi

      - name: Commit and Push
        run: |
          git add .
          git commit -m "chore: init workspace for ${{ steps.parse.outputs.protocol }}"
          git push origin ${{ env.TARGET_BRANCH }}

      - name: Notify
        uses: actions/github-script@v6
        with:
          script: |
            const branch = process.env.TARGET_BRANCH;
            const block = "${{ steps.infura.outputs.block_number }}";
            const date = "${{ steps.infura.outputs.date }}";
            const chainId = "${{ steps.parse.outputs.chain_id }}";
            const protocol = "${{ steps.parse.outputs.protocol }}";
            const replayStatus = process.env.REPLAY_STATUS;
            const auditors = JSON.parse('${{ steps.parse.outputs.auditors }}');
            const auditorMentions = auditors.map(a => `@${a}`).join(' ');
            
            const comment = `**Workspace Ready**

| Item | Value |
|------|-------|
| Branch | \`${branch}\` |
| Date | ${date} |
| Block | ${block} |
| Replay | ${replayStatus} |

**Assigned:** ${auditorMentions}

\`\`\`bash
git fetch origin && git checkout ${branch}
\`\`\``;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
